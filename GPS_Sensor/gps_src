
#include <stdio.h>
#include <string.h>
#include <main.h>
#include "gps.h"
#include "CAN.h"
extern UART_HandleTypeDef huart6;  //uart1 is used to receive gps data(D2 PIN-CN9)
extern UART_HandleTypeDef huart2;  //uart2 is used to transmit received data(display)
//extern CAN_TxHeaderTypeDef TxHeader;
#define GPS_USART &huart6

char buffer_lat[100];    //To store latitude value
char buffer_long[100];   //To store longitude value

#if (GPS_DEBUG == 1)
#include <usbd_cdc_if.h>
#endif

uint8_t rx_data = 0;
uint8_t rx_buffer[GPSBUFSIZE];
uint8_t rx_index = 0;

GPS_t GPS;

#if (GPS_DEBUG == 1)
void GPS_print(char *data)
{
	char buf[GPSBUFSIZE] = {0,};
	sprintf(buf, "%s\n", data);
	
#endif

void GPS_Init()
{
	HAL_UART_Receive_IT(GPS_USART, &rx_data, 1);
}

void GPS_UART_CallBack()
{
	if (rx_data != '\n' && rx_index < sizeof(rx_buffer))
	{
		rx_buffer[rx_index++] = rx_data;
	}
	else
	{

		#if (GPS_DEBUG == 1)
		GPS_print((char*)rx_buffer);
		#endif

		if(GPS_validate((char*) rx_buffer))
			GPS_parse((char*) rx_buffer);
		rx_index = 0;
		memset(rx_buffer, 0, sizeof(rx_buffer)); //To empty rx_buffer
	}

	HAL_UART_Receive_IT(GPS_USART, &rx_data, 1); //interrupt
}

int GPS_validate(char *nmeastr)
{
    char check[3];
    char checkcalcstr[3];
    int i;
    int calculated_check;

    i=0;
    calculated_check=0;

    // check to ensure that the string starts with a $
    if(nmeastr[i] == '$')
        i++;
    else
        return 0;

    //No NULL reached, 75 char largest possible NMEA message, no '*' reached
    while((nmeastr[i] != 0) && (nmeastr[i] != '*') && (i < 75))
    {
        calculated_check ^= nmeastr[i];// calculate the checksum
        i++;
    }

    if(i >= 75)
    {
        return 0;// the string was too long so return an error
    }

    if (nmeastr[i] == '*')
    {
        check[0] = nmeastr[i+1];    //put hex chars in check string
        check[1] = nmeastr[i+2];
        check[2] = 0;
    }
    else
        return 0;// no checksum separator found there for invalid

    sprintf(checkcalcstr,"%02X",calculated_check);
    return((checkcalcstr[0] == check[0]) && (checkcalcstr[1] == check[1])) ? 1 : 0 ;
}
void GPS_parse(char *GPSstrParse){
    if(!strncmp(GPSstrParse, "$GPGGA", 6))
    {
    	/*if (sscanf(GPSstrParse, "$GPGGA,%f,%f,%c,%f,%c,%d,%d,%f,%f,%c", &GPS.utc_time, &GPS.nmea_latitude, &GPS.ns, &GPS.nmea_longitude, &GPS.ew, &GPS.lock, &GPS.satelites, &GPS.hdop, &GPS.msl_altitude, &GPS.msl_units) >= 1)
    	{
    		GPS.dec_latitude = GPS_nmea_to_dec(GPS.nmea_latitude, GPS.ns);
    		GPS.dec_longitude = GPS_nmea_to_dec(GPS.nmea_longitude, GPS.ew);

    		return;
    		
    	}*/
    }
    else if (!strncmp(GPSstrParse, "$GPRMC", 6))
    {
    	if(sscanf(GPSstrParse, "$GPRMC,%f,%f,%c,%f,%c,%f,%f,%d", &GPS.utc_time, &GPS.nmea_latitude, &GPS.ns, &GPS.nmea_longitude, &GPS.ew, &GPS.speed_k, &GPS.course_d, &GPS.date) >= 1)
    		return;

    }

    else if (!strncmp(GPSstrParse, "$GPVTG", 6))
    {
        if(sscanf(GPSstrParse, "$GPVTG,%f,%c,%f,%c,%f,%c,%f,%c", &GPS.course_t,&GPS.course_t_unit, &GPS.course_m, &GPS.course_m_unit, &GPS.speed_k, &GPS.speed_k_unit, &GPS.speed_km, &GPS.speed_km_unit) >= 1)
            return;
    }
    sprintf (buffer_lat, "Lattitude-%.4f \n\r ", GPS.dec_latitude);  //printing the latitude and longitude using uart2
    
    HAL_UART_Transmit(&huart2,buffer_lat, strlen(buffer_lat), 100);
    sprintf (buffer_long, "Longitude-%.4f \n\r\n\r ", GPS.dec_longitude);
    HAL_UART_Transmit(&huart2,buffer_long, strlen(buffer_long), 100);
}


